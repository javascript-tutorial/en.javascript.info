# Фокусировка: focus/blur

Говорят, что элемент "получает фокус", когда посетитель фокусируется на нём. Обычно фокусировка автоматически происходит при нажатии на элементе мышкой, но также можно перейти на нужный элемент клавиатурой -- через клавишу [key Tab], нажатие пальцем на планшете и так далее.

Момент получения фокуса и потери очень важен. 

При получении фокуса мы можем подгрузить данные для автодополнения, начать отслеживать изменения. При потере -- проверить данные, которые ввёл посетитель. 

Кроме того, иногда полезно "вручную", из JavaScript перевести фокус на нужный элемент, например, на поле в динамически созданной форме.

[cut]
## События focus/blur

Событие `focus` вызывается тогда, когда пользователь фокусируется на элементе, а  `blur` -- когда фокус исчезает, например посетитель кликает на другом месте экрана.

Давайте сразу посмотрим на них в деле, используем для проверки ("валидации") введённых в форму значений.

В примере ниже:
<ul>
<li>Обработчик `onblur` проверяет, что в поле введено число, если нет -- показывает ошибку.</li>
<li>Обработчик `onfocus`, если текущее состояние поля ввода -- "ошибка" -- скрывает её (потом при `onblur` будет повторная проверка).</li>
</ul>

В примере ниже, если набрать что-нибудь в поле "возраст" и завершить ввод, нажав [key Tab] или кликнув в другое место страницы, то введённое значение будет автоматически проверено:

```html
<!--+ run autorun height=60 -->
<style> .error { border-color: red; } </style>

Введите ваш возраст: <input type="text" id="input">

<div id="error"></div>

<script>
*!*input.onblur*/!* = function() {
  if (isNaN(this.value)) { // введено не число
    // показать ошибку
    this.className = "error";
    error.innerHTML = 'Вы ввели не число. Исправьте, пожалуйста.'
  }
};

*!*input.onfocus*/!* = function() { 
  if (this.className == 'error') { // сбросить состояние "ошибка", если оно есть 
    this.className = "";
    error.innerHTML = "";
  }
};
</script>
```

## Методы focus/blur

Методы с теми же названиями переводят/уводят фокус с элемента.

Для примера модифицируем пример выше, чтобы при неверном вводе посетитель просто не мог уйти с элемента:

```html
<!--+ run autorun height=80 -->
<style>
  .error {
    background: red;
  }
</style>

<div>Возраст:
  <input type="text" id="age">
</div>

<div>Имя:
  <input type="text">
</div>

<script>
  age.onblur = function() {
    if (isNaN(this.value)) { // введено не число
      // показать ошибку
      this.classList.add("error");
*!*
      age.focus();
*/!* 
    } else {
      this.classList.remove("error");
    }
  };
</script>
```

Если в примере выше ввести что-то нецифровое в поле "возраст", и потом попытаться табом или мышкой перейти на другой `<input>`, то обработчик `onblur` вернёт фокус обратно.

Обратим внимание -- если из `onblur` сделать `event.preventDefault()`, то такого же эффекта не будет, потому что `onblur` срабатывает уже *после* того, как элемент потерял фокус.

## HTML5 и CSS3 вместо focus/blur

Прежде чем переходить к более сложным примерам, использующим JavaScript, мы рассмотрим три примера, когда его использовать не надо, а достаточно современного HTML/CSS.

### Подсветка при фокусировке

Стилизация полей ввода может быть решена средствами CSS (CSS2.1), а именно -- селектором `:focus`:

```html
<!--+ autorun -->
<style> 
*!*input:focus*/!* { 
  background: #FA6; 
  outline: none;  /* убрать рамку */
} 
</style>
<input type="text"> 

<p>Селектор :focus выделит элемент при фокусировке на нем и уберёт рамку, которой браузер выделяет этот элемент по умолчанию.</p>
```

В IE (включая более старые) скрыть фокус также может установка специального атрибута [hideFocus](http://msdn.microsoft.com/en-us/library/ie/ms533783.aspx).

### Автофокус

При загрузке страницы, если на ней существует элемент с атрибутом `autofocus` -- браузер автоматически фокусируется на этом элементе. Работает во всех браузерах, кроме IE9-.

```html
<!--+ run link -->
<input type="text" name="search" *!*autofocus*/!*>
```

Если нужны старые IE, то же самое может сделать JavaScript:

```html
<input type="text" name="search">
<script>
  document.getElementsByName('search')[0].focus();
</script>
```

Как правило, этот атрибут используется при изначальной загрузке, для страниц поиска и так далее, где главный элемент очевиден.

### Плейсхолдер

*Плейсхолдер* -- это значение-подсказка внутри `INPUT`, которое автоматически исчезает при фокусировке и существует, пока посетитель не начал вводить текст.

Во всех браузерах, кроме IE9-, это реализуется специальным атрибутом `placeholder`:

```html
<!--+ autorun -->
<input type="text" placeholder="E-mail">
```

В некоторых браузерах этот текст можно стилизовать:

```html
<!--+ autorun -->
<style>
.my*!*::-webkit-input-placeholder*/!*, .my*!*::-moz-placeholder*/!* {
  color: red;
  font-style: italic;
}
</style>

<input class="my" type="text" placeholder="E-mail"> 
Стилизуется везде, кроме IE
```

## Разрешаем фокус на любом элементе: tabindex

По умолчанию не все элементы поддерживают фокусировку.

Перечень элементов немного рознится от браузера к браузеру, например, список для IE описан <a href="http://msdn.microsoft.com/en-us/library/ms536934.aspx">в MSDN</a>, одно лишь верно всегда -- заведомо поддерживают `focus/blur` те элементы, c которыми посетитель может взаимодействовать: `<button>`, `<input>`, `<select>`, `<a>` и т.д.

С другой стороны, на элементах для форматирования, таких как `<div>`, `<span>`, `<table>` -- по умолчанию сфокусироваться нельзя. Впрочем, существует способ включить фокусировку и для них.

В HTML есть атрибут `tabindex`. 

Его основной смысл -- это указать номер элемента при переборе клавишей [key Tab].

То есть, если есть два элемента, первый имеет `tabindex="1"`, а второй `tabindex="2"`, то нажатие [key Tab] при фокусе на первом элементе -- переведёт его на второй.

Исключением являются специальные значения:
<ul>
<li>`tabindex="0"` делает элемент всегда последним.</li>
<li>`tabindex="-1"` означает, что клавиша [key Tab] будет элемент игнорировать.</li>
</ul>

**Любой элемент поддерживает фокусировку, если у него есть `tabindex`.**

В примере ниже есть список элементов. Кликните на любой из них и нажмите "tab".

```html
<!--+ autorun  no-beautify -->
Кликните на первый элемент списка и нажмите Tab. Внимание! Дальнейшие нажатия Tab могут вывести за границы iframe'а с примером.
<ul>
  <li tabindex="1">Один</li>
  <li tabindex="0">Ноль</li>
  <li tabindex="2">Два</li>
  <li tabindex="-1">Минус один</li>
</ul>

<style> 
  li { cursor: pointer; }
  :focus { outline: 1px dashed green; } 
</style>
```

Порядок перемещения по клавише "Tab" в примере выше должен быть таким: `1 - 2 - 0` (ноль всегда последний). Продвинутые пользователи частенько используют "Tab" для навигации, и ваше хорошее отношение к ним будет вознаграждено :)

Обычно `<li>` не поддерживает фокусировку, но здесь есть `tabindex`.

## Делегирование с focus/blur 

События `focus` и `blur` не всплывают.

Это грустно, поскольку мы не можем использовать делегирование с ними. Например, мы не можем сделалать так, чтобы при фокусировке в форме она вся подсвечивалась:

```html
<!--+ autorun height=auto -->
<form *!*onfocus="this.className='focused'"*/!*>
  <input type="text" name="name" value="Ваше имя">
  <input type="text" name="surname" value="Ваша фамилия">
</form>

<style> .focused { outline: 1px solid red; } </style>
```

В примере выше стоит обработчик `onfocus` на форме, но он не работает, т.к. при фокусировке на любом `INPUT` событие `focus` срабатывает только на этом элементе и не всплывает наверх.

Что делать? Неужели мы должны присваивать обработчик каждому полю?

**Это забавно, но хотя `focus/blur` не всплывают, они могут быть пойманы на фазе перехвата.**

Вот так сработает:

```html
<!--+ autorun height=auto -->
<form id="form">
  <input type="text" name="name" value="Ваше имя">
  <input type="text" name="surname" value="Ваша фамилия">
</form>

<style>
  .focused {
    outline: 1px solid red;
  }
</style>

<script>
*!*
  // ставим обработчики на фазе перехвата, последний аргумент true
  form.addEventListener("focus", function() {
    this.classList.add('focused');
  }, true);

  form.addEventListener("blur", function() {
    this.classList.remove('focused');
  }, true);
*/!*
</script>
```

### События focusin/focusout

События `focusin/focusout` -- то же самое, что и `focus/blur`, только они всплывают.

У них две особенности:
<ul>
<li>Не поддерживаются Firefox, хотя поддерживаются даже старейшими IE.</li>
<li>Во всех браузерах, кроме IE, должны быть назначены не через `on`-свойство, а при помощи `elem.addEventListener`.</li>
</ul>

Для кросс-браузерной поддержки фокуса с делегированием можно использовать сочетать эти события с фазой перехвата.

Подсветка формы в примере ниже работает во всех браузерах.

```html
<!--+ autorun height=60 run -->
<form name="form">
  <input type="text" name="name" value="Ваше имя">
  <input type="text" name="surname" value="Ваша фамилия">
</form>
<style>
  .focused {
    outline: 1px solid red;
  }
</style>

<script>
  function onFormFocus() {
    this.className = 'focused';
  }

  function onFormBlur() {
    this.className = '';
  }

  var form = document.forms.form;

  if (form.addEventListener) {
    form.addEventListener('focus', onFormFocus, true);
    form.addEventListener('blur', onFormBlur, true);
  } else { // IE8-
    form.onfocusin = onFormFocus;
    form.onfocusout = onFormBlur;
  }
</script>
```

## Итого
События `focus/blur` происходят при получении и снятия фокуса с элемента.

У них есть особенности:
<ul>
<li>Они не всплывают. Но на фазе перехвата их можно перехватить. Это странно, но это так, не спрашивайте почему.

Везде, кроме Firefox, поддерживаются всплывающие альтернативы `focusin/focusout`.</li>
<li>По умолчанию многие элементы не могут получить фокус. Например, если вы кликните по `DIV`, то фокусировка на нем не произойдет.

Но это можно изменить, если поставить элементу атрибут `tabIndex`. Этот атрибут также дает возможность контролировать порядок перехода при нажатии [key Tab].
</li>
</ul>

Текущий элемент, на котором фокус, доступен как `document.activeElement`.









