# Эволюция шаблонных систем для JavaScript

Различных шаблонных систем -- много.

Они постепенно эволюционировали и развивались. 

В этой главе мы разберём, как шёл этот процесс, какие шаблонки "родились", какие бонусы нам даёт использование той или иной шаблонной системы.
[cut]

## Микрошаблоны

*Микрошаблоны* (англ. microtemplate) мы уже видели на примере `_.template`.

Это HTML со вставками переменных и произвольным JS.

Пример:

```html
<!--+ no-beautify -->
<div class="menu">
  <span class="title"><%-title%></span>
  <ul>
    <% items.forEach(function(item) { %>
    <li><%-item%></li>
    <% }); %>
  </ul>
</div>
```

Шаблонная система компилирует этот код в JavaScript-функцию с минимальными модификациями, и она уже, запустившись с данными, генерирует результат.

Достоинства и недостатки такого подхода:

[compare]
-Жёстко привязан к языку JavaScript.
-При ошибке в шаблоне приходится лезть внутрь "страшной" функции
+Простая и быстрая шаблонная система
+Внутри JS-функции доступен полноценный браузерный отладчик, функция хоть и страшна, но понятна.
[/compare]

### Код в шаблоне

Включение произвольного JS-кода в шаблон, в теории, позволяет делать в нём всё, что угодно. Но обратная сторона медали -- шаблон вместо внятного HTML может стать адским нагромождением разделителей вперемешку с вычислениями. Что рекомендуется делать в шаблонах, а что нет?

Можно разделить код на два типа с точки зрения шаблонизации:
<ul>
<li>**Бизнес-логика** -- код, *формирующий данные*, основной код приложения.</li>
<li>**Презентационная логика** -- код, описывающий, как *показываются данные*.</li>
</ul>

Например, код, получающий данные с сервера для вывода в таблице -- бизнес-логика, а код, форматирующий даты для вывода -- презентационная логика. 

В шаблонах допустима лишь презентационная логика.

### Кросс-платформенность

Зачастую, нужно использовать один и тот же шаблон и в браузере и на сервере.

Например, серверный код генерирует HTML со списком сообщений, а JavaScript на клиенте добавляет к нему новые по мере появления.

...Но как использовать на сервере шаблон с JavaScript, если его основной язык -- PHP, Ruby, Java?

Эту проблему можно обойти. На сервер, использующем PHP, Ruby, Java или какой-то другой язык, дополнительно ставится виртуальная машина [V8](http://code.google.com/p/v8/) и настраивается интеграция с ней. Почти все платформы это умеют.

После этого становится возможным запускать JavaScript-шаблоны и передавать им данные в виде объектов, массивов и так далее.

Этот подход может показаться искусственным, но на самом деле он вполне жизнеспособен и используется в ряде крупных проектов.

### Прекомпиляция 

Эта шаблонка и большинство других систем, которые мы рассмотрим далее, допускают *прекомпиляцию*.

То есть, можно заранее, до выкладывания сайта на "боевой сервер", обработать шаблоны, создать из них JS-функции, объединить их в единый файл и далее, в "боевом окружении" использовать уже их.

Современные системы сборки ([brunch](http://brunch.io/), [grunt](http://gruntjs.com/) с плагинами и другие) позволяют делать это удобно, а также хранить шаблоны в разных файлах, каждый -- в нужной директории с JS-кодом для виджета.

## Хелперы и фильтры

JavaScript-вставки не всегда просты и элегантны. Иногда, чтобы что-то сделать, нужно написать порядочно кода.

**Для того, чтобы сделать шаблоны компактнее и проще, в них стали добавлять фильтры и хелперы.**

<ul>
<li>**Хелпер** (англ. helper) -- вспомогательная функция, которая доступна в шаблонах и используется для решения часто возникающих задач. 

В `_.template`, чтобы объявить хелпер, можно просто сделать глобальную функцию. Но это слишком грубо, так не делают. Гораздо лучше -- использовать объект `_.templateSettings.imports`, в котором можно указать, какие функции добавлять в шаблоны, или опцию `imports` для `_.template`.

Пример хелпера -- функция `t(phrase)`, которая переводит `phrase` на текущий язык:

```js
//+ run
_.templateSettings.imports.t = function(phrase) {
  // обычно функция перевода немного сложнее, но здесь это не важно
  if (phrase == "Hello") return "Привет";
}

*!*
// в шаблоне используется хелпер t для перевода 
var compiled = _.template("<div><%=t('Hello')%></div>");
*/!*
alert( compiled() ); // <div>Привет</div>
```

Такой хелпер очень полезен для мультиязычных сайтов, когда один шаблон нужно выводить на десяти языках. Нечто подобное используется почти во всех языках и платформах, не только в JavaScript.
</li>
<li>**Фильтр** -- это функция, которая трансформирует данные, например, форматирует дату, сортирует элементы массива и так далее.

Обычно для фильтров обычно предусмотрен специальный "особо простой и короткий" синтаксис.

Например, в системе шаблонизации [EJS](https://github.com/visionmedia/ejs), которая по сути такая же, но мощнее, чем `_.template`, фильтры задаются через символ `|`, внутри разделителя `<%=: ... %>`.

Чтобы вывести `item` с большой буквы, можно вместо `<%=item%>` написать `<%=: item | capitalize %>`. Чтобы выводить отсортированный массив, можно использовать `<%=: items | sort %>` и так далее.
</li>
</ul>

## Свой язык

Для того, чтобы сделать шаблон ещё короче, а также с целью "отвязать" их от JavaScript, ряд шаблонных систем предлагают свой язык.

Например:
<ul>
<li>[Mustache](http://mustache.github.com/)</li>
<li>[Handlebars](http://handlebarsjs.com/)</li>
<li>[Closure Templates](https://developers.google.com/closure/templates/docs/javascript_usage)</li>
<li>...тысячи их...</li>
</ul>

Шаблон для меню в Handlerbars, к примеру, будет выглядеть так:

```html
<!--+ no-beautify -->
<div class="menu">
  <span class="title">{{title}}</span>
  <ul>
    {{#each items}}
    <li>{{item}}</li>
    {{/each}}
  </ul>
<div>
```

Как видно, *вместо* JavaScript-конструкций здесь используются хелперы. В примере выше `{{#each}} ... {{/each}` -- "блочный" хелпер: он показывает своё содержимое для каждого элемента `items` и является альтернативой `forEach`.

Есть и другие встроенные в шаблонизатор хелперы, можно легко делать свои.

Использование такого шаблона:

```js
// текст шаблона должен быть в переменной tmpl
var compiled = Handlebars.compile(tmpl);

var result = compiled({
  title: "Сладости",
  items: ["Торт", "Пирожное", "Пончик"]
});
```

Библиотека шаблонизации [Handlebars](http://handlebarsjs.com/) "понимает" этот язык. Вызов `Handlebars.compile` принимает строку шаблона, разбивает по разделителям и, аналогично предыдущему виду шаблонов, делает JavaScript-функцию, которая затем по данным выдаёт строку-результат.

### Запрет на встроенный JS

Если "свой язык шаблонизатора" очень прост, то библиотеку для его поддержки можно легко написать под PHP, Ruby, Java и других языках, которые тем самым научатся понимать такие шаблоны.

**Если шаблонка действительна нацелена на кросс-платформенность, то явные JS-вызовы в ней запрещены. Всё делается через хелперы.**

Если же нужна какая-то логика, то она либо выносится во внешний код, либо делается через новый хелпер --  он отдельно пишется на JavaScript (для клиента) и для сервера (на его языке). Получается полная совместимость.

Это создаёт определённые сложности. Например, в Handlebars есть хелпер `{{#if cond}} ... {{/if}}`, который выводит содержимое, если истинно условие `cond`. При этом вместо `cond` нельзя поставить, к примеру, `a > b` или вызов `str.toUpperCase()`, будет ошибка. Все вычисления должны быть сделаны на этапе передачи данных в шаблон. 

Так сделано как раз для переносимости шаблонной системы на другие языки, но на практике не очень-то удобно.

Продвинутые кросс-платформенные шаблонизаторы, в частности, [Closure Templates](https://developers.google.com/closure/templates/docs/javascript_usage), обладают более мощным языком и умеют самостоятельно разбирать и компилировать многие выражения. 

## Шаблонизация компонент

До этого мы говорили о шаблонных системах "общего назначения". По большому счёту, это всего лишь механизмы для преобразования одной строки в другую. Но при описании шаблона для компоненты мы хотим сгенерировать не просто строку, а DOM-элемент, и не просто генерировать, а в дальнейшем -- с ним работать. 

Современные шаблонные системы "заточены" на это. Они умеют создавать по шаблону DOM-элементы и автоматически выполнять после этого разные полезные действия.

Например:
<ul>
<li>Можно сохранить важные подэлементы в свойства компоненты, чтобы было проще к ним обращаться из JavaScript.</li>
<li>Можно автоматически назначать обработчики из методов компонента.</li>
<li>Можно запомнить, какие данные относятся к каким элементам и в дальнейшем, при изменении данных автоматически обновлять DOM ("привязка данных" -- англ. data binding).</li>
</ul>

Одной из первых систем шаблонизации, которая поддерживает подобные возможности была [Knockout.JS](http://knockoutjs.com).

Попробуйте поменять значение `<input>` в примере ниже и вы увидите двухстороннюю привязку данных в действии:

```html
<!--+ run height=120 autorun -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.3.0/knockout-min.js"></script>

Поменяйте имя: <input *!*data-bind="value: name, valueUpdate: 'input'"*/!*>
<hr>
<h1>Привет, <span *!*data-bind="text: name"*/!*></span>!</h1>

<script>
var user = {
  name: ko.observable("Вася")
};

ko.applyBindings(user, document.body); 
</script>
```

Библиотека Knockout.JS создаёт объект `ko`, который и содержит все её возможности.

В этом примере работу начинает вызов `ko.applyBindings(user, document.body)`. 

Его аргументы:

<ul>
<li>`user` -- объект с данными.</li>
<li>`document.body` -- DOM-элемент, который будет использован в качестве шаблона.</li>
</ul>

Он пробегает по всем подэлементам `document.body` и, если видит атрибут `data-bind`, то читает его и выполняет привязку данных. 

Значение `<input data-bind="value: name, ...">` означает, что нужно привязать `input.value` к свойству `name` объекта данных.

Привязка осуществляется в две стороны:
<ol>
<li>Во-первых, библиотека ставит на `input` свой обработчик `oninput` (можно выбрать другие события, см. [документацию](http://knockoutjs.com/documentation/value-binding.html)), который будет обновлять `user.name`. То есть, изменение `input` автоматически меняет `user.name`</li>
<li>Во-вторых, свойство `user.name` создано как `ko.observable(...)`. Технически, `ko.observable(value)` -- это функция-обёртка вокруг значения: геттер-сеттер, который умеет рассылать события при изменении.

Например:

```html
<!--+ run  no-beautify -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.3.0/knockout-min.js"></script>

<script>
var user = ko.observable("Вася");

*!*
// вызов user() возвращает значение
*/!*
alert( user() ); // Вася

*!*
// вызов user.subscribe(func) ставит обработчик на изменение значения
*/!*
user.subscribe(function(newValue) {
  alert("Новое значение: " + newValue);
});

*!*
// вызов user(newValue) меняет значение
*/!*
user("Петя"); // сработает обработчик, назначенный выше
</script>
```

Библиотека Knockout.JS ставит свой обработчик на изменение значения и при этом обновляет все привязки. Так что при изменении `user.name` меняется и `input.value`.
</li>
</ol>

Далее в том же примере находится `<span data-bind="text: name">` -- здесь атрибут означает привязку текста к `name`. Так как `<span>` по своей инициативе меняться не может, то привязка односторонняя, но если бы мог, то можно сделать и двухстороннюю, это несложно.

**Вызов `ko.applyBindings` можно делать внутри компоненты, и таким образом устанавливать соответствия между её объектом и DOM.**

Библиотка также поддерживает хранение шаблонов в `<script type="text/template">` -- см. документацию [template-binding](http://knockoutjs.com/documentation/template-binding.html), можно организовать прекомпиляцию, добавлять свои привязки и так далее.

### Другие библиотеки

Есть другие библиотеки "продвинутой шаблонизации", которые добавляют свои возможности по работе с DOM, например:

<ul>
<li>[Ractive.JS](http://www.ractivejs.org)</li>
<li>[Rivets.JS](http://www.rivetsjs.com/)</li>
</ul>

Подобная шаблонная система является частью многих фреймворков, например:
<ul>
<li>[React.JS](http://facebook.github.io/react/)</li>
<li>[Angular.JS](http://angularjs.org)</li>
<li>[Ember.JS](http://emberjs.com/)</li>
</ul>

Все эти фреймворки разные:
<ul>
<li>Ember использует надстройку над Handlebars.</li>
<li>React использует JSX ([JavaScript XML syntax transform](http://facebook.github.io/react/docs/jsx-in-depth.html)) -- свой особый способ вставки разметки в JS-код, который нужно обязательно прекомпилировать перед запуском.</li>
<li>Angular вместо работы со строками использует клонирование DOM-узлов.</li>
</ul>

При разработке современного веб-приложения имеет смысл выбрать продвинутую шаблонную систему или даже один из этих архитектурных фреймворков.

## Итого

Системы шаблонизации, в порядке развития и усложнения:

<ul>
<li>Микрошаблонизация -- строка с JS-вставками, которая компилируется в функцию -- самый простой вариант, минимальная работа для шаблонизатора.</li>
<li>Собственный язык шаблонов -- "особо простой" синтаксис для частых операций, с запретом на JS в случае, если нужна кросс-платформенность.</li>
<li>Шаблонизация для компонентов -- современные системы, которые умеют не только генерировать DOM, но и помогать с дальнейшей работой с ним.</li>
</ul>

Для того, чтобы использовать одни и те же шаблоны на клиенте и сервере, применяют либо кросс-платформенную систему шаблонизации, либо, чаще -- интегрируют серверную часть с V8 и, возможно, с сервером Node.JS.

В главе было много ссылок на шаблонные системы. Все они достаточно современные, поддерживаемые и используются во многих проектах. Среди них вы наверняка найдёте нужную вам.

