Вызов `alert(i)` в `setTimeout` введет `100000001`. 

Можете проверить это запуском:

```js
//+ run
var timer = setInterval(function() { 
  i++;
}, 10);

setTimeout(function() { 
  clearInterval(timer);
*!*
  alert(i); // (*)
*/!*
}, 50);

var i;

function f() { 
  // точное время выполнения не играет роли
  // здесь оно заведомо больше 100мс
  for(i=0; i<1e8; i++) f[i%2] = i;
}

f();
```

Правильный вариант срабатывания: **3** (сразу же по окончании `f` один раз).

Планирование `setInterval` будет вызывать функцию каждые `10мс` после текущего времени. Но так как интерпретатор занят долгой функцией, то до конца ее работы никакого вызова не происходит.

За время выполнения `f` может пройти время, на которое запланированы несколько вызовов `setInterval`, но в этом случае остается только один, т.е. накопления вызовов не происходит. Такова логика работы `setInterval`. 

После окончания текущего скрипта интерпретатор обращается к очереди запланированных вызовов, видит в ней `setInterval` и выполняет. А затем тут же выполняется  `setTimeout`, очередь которого тут же подошла. 

Итого, как раз и видим, что `setInterval` выполнился ровно 1 раз по окончании работы функции. Такое поведение кросс-браузерно.