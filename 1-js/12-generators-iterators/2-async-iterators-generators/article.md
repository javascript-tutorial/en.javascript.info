
# Асинхронные итераторы и генераторы

Асинхронные итераторы позволяют перебирать данные, поступающие асинхронно по запросу.

Например, когда мы загружаем что-то по частям (chunk) или ожидаем, что события будут происходить асинхронно, и нам хотелось бы их перебирать - как раз и пригождаются асинхронные итераторы и генераторы. Давайте сначала рассмотрим простой пример, чтобы понять синтаксис, а затем - реальный практический.

## Асинхронные итераторы

Асинхронные итераторы полностью аналогичны обычным итераторам, но имеют некоторые синтаксическими отличиями.

«Обычный» итерируемый объект из главы <info:iterable> выглядит следующим образом:

```js run
let range = {
  from: 1,
  to: 5,

  // for..of вызывает этот метод один раз в самом начале
*!*
  [Symbol.iterator]() {
*/!*
    // ...возвращает объект-итератор:
    // далее, for..of работает только с объектами, запрашивая следующее значение
    return {
      current: this.from,
      last: this.to,

      // next() вызывается на каждой итерации с помощь цикла for..of 
*!*
      next() { // (2)
        // должен возвращать значение в виде объекта {done:.., value :...}
*/!*
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for(let value of range) {
  alert(value); // 1 потом 2, потом 3, потом 4, потом 5
}
```

Если нужно, пожалуйста, ознакомьтесь с [главой про итераторы](info:iterable), где обычные итераторы разбираются подробно.

Чтобы сделать объект итерируемым асинхронно:
1. Нужно использовать `Symbol.asyncIterator` вместо `Symbol.iterator`.
2. `next()` должен возвращать обещание (promise).
3. Чтобы перебрать такой объект, нужно использовать цикл `for await (let item of iterable)`.

Давайте создадим итеративный объект `range`, как и в предыдущем примере, но теперь он будет возвращать значения асинхронно, по одному в секунду:

```js run
let range = {
  from: 1,
  to: 5,

  // for..of вызывает этот метод один раз в самом начале
*!*
  [Symbol.asyncIterator]() { // (1)
*/!*
    // ...возвращает объект-итератор:
    // далее, for..of работает только с объектами, запрашивая следующее значение
    return {
      current: this.from,
      last: this.to,

      // next() вызывается на каждой итерации с помощь цикла for..of 
*!*
      async next() { // (2)
        // должен возвращать значение как объект {done:.., value :...}
        // (автоматически упаковывается в обещание с помощью async)
*/!*

        // можно использовать await внутни для асинхронности:
        await new Promise(resolve => setTimeout(resolve, 1000)); // (3)

        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

(async () => {

*!*
  for await (let value of range) { // (4)
    alert(value); // 1,2,3,4,5
  }
*/!*

})()
```

Как мы видим, компоненты похожи на обычные итераторы:

1. Чтобы сделать объект итеративным асинхронно, он должен иметь метод `Symbol.asyncIterator`` (1) `.
2. Он должен возвращать объект с методом `next ()`, который в свою очередь возвращает обещание `(2)`.
3. Метод `next ()` не обязательно должен быть `async`, он может быть обычным методом, возвращающим обещание, но` async` позволяет использовать `await` внутри. Здесь мы просто создаем паузу на одну секунду `(3)`.
4. Для итерации мы используем `for await (let value of range)` `(4)`, а именно добавляем "await" после "for". Вызываем `range [Symbol.asyncIterator]()` один раз, а затем его метод `next()` для получения значений.

Вот небольшая шпаргалка:

|       | Итераторы | Async-интераторы |
|-------|-----------|-----------------|
| Метод для создания итерируемого объекта | `Symbol.iterator` | `Symbol.asyncIterator` |
| `next()` возвращает              | любое значение         | `Promise`  |
| для цикла используйте                          | `for..of`         | `for await..of` |


````warn header="Оператор spread (развертывания) не работает асинхронно"
Функции, которые требуют обычных синхронных итераторов, не работают с асинхронными.

Например, оператор spread (развертывания) не будет работать:
```js
alert([...range]); // Ошибка, нет Symbol.iterator
```

Это естественно, так как он ожидает `Symbol.iterator`, такой же, как` for..of` без `await`.
````

## Асинхронные генераторы

В Javascript также есть генераторы, которые являются итеративными.

Давайте вспомним генератор последовательности из главы [](info:generators). Он генерирует последовательность значений от `start` до `end` (или что угодно другое):

```js run
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}

for(let value of generateSequence(1, 5)) {
  alert(value); // 1, потом 2, потом 3, потом 4, потом 5
}
```

Обычно мы не можем использовать `await` в генераторах. Все значения должны поступать синхронно: нет места для задержки в `for..of`.

Но что если нам нужно использовать `await` в теле генератора? Для выполнения сетевых запросов, например.

Нет проблем, просто добавьте в начале `async`, например вот так:

```js run
*!*async*/!* function* generateSequence(start, end) {

  for (let i = start; i <= end; i++) {

*!*
    // ура, можно использовать await!
    await new Promise(resolve => setTimeout(resolve, 1000));
*/!*

    yield i;
  }

}

(async () => {

  let generator = generateSequence(1, 5);
  for *!*await*/!* (let value of generator) {
    alert(value); // 1, then 2, then 3, then 4, then 5
  }

})();
```

Теперь у нас есть асинхронный генератор, который можно перебирать с помощью `for await ... of`.

Это действительно очень просто. Мы добавляем ключевое слово `async`, и внутри генератора теперь можно использовать `await`, а также обещания и другие асинхронные функции.

С технической точки зрения, еще одно отличие асинхронного генератора заключается в том, что его метод `generator.next()` теперь тоже асинхронный и возвращает обещания (promise).

Вместо `result = generator.next()` для обычного, не асинхронного генератора, значения могут быть получены следующим образом:


```js
result = await generator.next(); // result = {value: ..., done: true/false}
```

## Итерируемые объекты при помощи асинхронных генераторов

Когда мы хотим сделать объект итеративным, нужно добавить к нему `Symbol.iterator`.

```js
let range = {
  from: 1,
  to: 5,
*!*
  [Symbol.iterator]() { ...return объект с next, чтобы сделать итерируемым...  }
*/!*
}
```

Обычная практика для `Symbol.iterator` - возвращать генератор, а не простой объект с `next`, как в предыдущем примере.

Давайте вспомним пример из главы [](info:generators):

```js run
let range = {
  from: 1,
  to: 5,

  *[Symbol.iterator]() { // сокращение для [Symbol.iterator]: function*()
    for(let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

for(let value of range) {
  alert(value); // 1, потом 2, потом 3, потом 4, потом 5
}
```

Здесь кастомный объект `range` является итеративным, а генератор `*[Symbol.iterator]` реализует логику для перечисления значений.

Если хотим добавить асинхронные действия в генератор, нужно заменить `Symbol.iterator` на асинхронный `Symbol.asyncIterator`:

```js run
let range = {
  from: 1,
  to: 5,

*!*
  async *[Symbol.asyncIterator]() { // то же, что и [Symbol.asyncIterator]: async function*()
*/!*
    for(let value = this.from; value <= this.to; value++) {

      // пауза между значениями, ожидание  
      await new Promise(resolve => setTimeout(resolve, 1000));

      yield value;
    }
  }
};

(async () => {

  for *!*await*/!* (let value of range) {
    alert(value); // 1, потом 2, потом 3, потом 4, потом 5
  }

})();
```

Теперь значения поступают с задержкой в одну секунду между ними.


## Пример из реальной практики

До сих пор мы видели простые примеры, чтобы просто получить базовое представление. Теперь давайте рассмотрим реальный пример использования.

Есть много онлайн-API, которые предоставляют постраничные данные (пагинация). Например, когда нам нужен список пользователей, мы можем получать его постранично: запрос возвращает предопределенное количество (например, 100) пользователей и URL для следующей страницы.

Этот подход очень распространен, и речь не только о пользователях, а о чем угодно. Например, Github позволяет получать коммиты таким образом, с разбивкой по страницам:

- Нужно сделать запрос на URL в виде `https://api.github.com/repos/<repo>/commits`.
- В ответ придет JSON с 30 коммитами, а также со ссылкой на следующую страницу в заголовке `Link`.
- Затем можно использовать эту ссылку для следующего запроса, чтобы получить дополнительную порцию коммитов, и так далее.

То, что нам бы помогло в этом случае, - это итеративный источник коммитов, чтобы можно было использовать его таким вот образом:

```js
let repo = 'iliakan/javascript-tutorial-en'; // репозиторий на Github, откуда брать коммиты

for await (let commit of fetchCommits(repo)) {
  // обработка комитов
}
```

Мы бы хотели, чтобы `fetchCommits` получал для нас коммиты, делая запросы всякий раз, когда это необходимо. И пусть он сам разбирается со всем, что касается нумерации страниц, для нас это будет просто `for await..of`.

С асинхронными генераторами это довольно легко реализовать:

```js
async function* fetchCommits(repo) {
  let url = `https://api.github.com/repos/${repo}/commits`;

  while (url) {
    const response = await fetch(url, { // (1)
      headers: {'User-Agent': 'Our script'}, // github требует хедер user-agent
    });

    const body = await response.json(); // (2) парсинг ответа в JSON (массив коммитов)

    // (3) URL со ссылкой на следующую страницу в хедерах, получите ее
    let nextPage = response.headers.get('Link').match(/<(.*?)>; rel="next"/);
    nextPage = nextPage && nextPage[1];

    url = nextPage;

    for(let commit of body) { // (4) отдавайте коммиты по одному до окончания страницы
      yield commit;
    }
  }
}
```

1. Мы используем метод `fetch` браузера для загрузки с удаленного URL. Он позволяет при необходимости добавлять авторизацию и другие заголовки, здесь Github требует `User-Agent`.
2. Результат `fetch` обрабатывается как JSON, это опять-таки метод, присущий `fetch`.
3. Мы можем получить URL следующей страницы из заголовка `Link` ответа. Он имеет специальный формат, поэтому для этого мы используем регулярное выражение. URL следующей страницы может выглядеть следующим образом: `https: //api.github.com/repositories/93253246/commits?page=2`, он генерируется самим Github'ом.
4. Затем мы выдаем все полученные коммиты, а когда они закончат - сработает следующая итерация `while (url)`, которая совершает еще один запрос.

Пример использования (показывает авторов коммитов в консоли):

```js run
(async () => {

  let count = 0;

  for await (const commit of fetchCommits('iliakan/javascript-tutorial-en')) {

    console.log(commit.author.login);

    if (++count == 100) { // остановимся на 100 коммитах
      break;
    }
  }

})();
```

Это именно то, что мы хотели. Механика внутренней нумерации снаружи невидна. Для нас это просто асинхронный генератор, который возвращает коммиты.

## Резюме

Обычные итераторы и генераторы прекрасно работают с данными, которые не требуют времени для их создания или получения.

Когда мы ожидаем, что данные будут поступать асинхронно, с задержками, могут использоваться их асинхронные аналоги и `for await..of` вместо` for..of`.

Синтаксические различия между асинхронными и обычными итераторами:


|       | Итераторы | Асинхронные итераторы |
|-------|-----------|-----------------|
| Метод для создания | `Symbol.iterator` | `Symbol.asyncIterator` |
| `next()` возвращает              | любое значение         | `Promise`  |

Синтаксические различия между асинхронными и обычными генераторами:

|       | Генераторы | Асинхронные генераторы |
|-------|-----------|-----------------|
| Объявление | `function*` | `async function*` |
| `generator.next()` возвращает              | `{value:…, done: true/false}`         | `Promise`, которое превращается в `{value:…, done: true/false}`  |

В веб-разработке мы часто встречаемся с потоками данных, когда они поступают по частям. Например, загрузка или выгрузка большого файла.

Мы могли бы использовать асинхронные генераторы для обработки таких данных, но есть и другой API, называемый Streams (потоки), который может быть более удобным, поскольку он предоставляет специальные интерфейсы для преобразования данных и передачи их из одного потока в другой (например, загрузка из одного источника и сразу отправка в другое место). Но они более сложные.

Streams API не является частью стандарта языка Javascript. Потоки и асинхронные генераторы дополняют друг друга, оба являются отличными способами обработки асинхронных потоков данных.