# Основные операторы

Для работы с переменными, со значениями, JavaScript поддерживает все стандартные операторы, большинство которых есть и в других языках программирования.

Несколько операторов мы знаем со школы -- это обычные сложение `+`, умножение `*`, вычитание и так далее.

В этой главе мы сконцентрируемся на операторах, которые в на математике не проходят и на их особенностях именно в JavaScript.
[cut]

## Термины: "унарный", "бинарный", "операнд"

У операторов есть своя терминология, которая используется во всех языках программирования.

Прежде, чем мы двинемся дальше -- несколько терминов, чтобы понимать, о чём речь.

<ul>
<li>*Операнд* -- то, к чему применяется оператор. Например: `5 * 2` -- оператор умножения с левым и правым операндами. Другое название: "аргумент оператора".</li>
<li>*Унарным* называется оператор, который применяется к одному выражению. Например, оператор унарный минус `"-"` меняет знак числа на противоположный:

```js
//+ run
var x = 1;

*!*
x = -x;
*/!*
alert( x );     // -1, применили унарный минус
```

</li>
<li>*Бинарным* называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

```js
//+ run
var x = 1, y = 3;
alert( y - x ); // 2, бинарный минус
```
</li>
</ul>


## Сложение строк, бинарный +

Обычно при помощи плюса `'+'` складывают числа.

Но если бинарный оператор `'+'` применить к строкам, то он их объединяет в одну:

```js
var a = "моя" + "строка";
alert(a); // моястрока
```

Иначе говорят, что "плюс производит конкатенацию (сложение) строк".

**Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!**

Причем не важно, справа или слева находится операнд-строка, в любом случае нестроковый аргумент будет преобразован. Например:

```js
//+ run
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

**Это приведение к строке -- особенность исключительно бинарного оператора `"+"`.**

Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.

Например:

```js
//+ run
alert( 2 - '1' ); // 1
alert( 6 / '2'); // 3 
```



### Преобразование к числу, унарный плюс +

Унарный, то есть применённый к одному значению, плюс ничего не делает с числами:

```js
//+ run
alert( +1 ); // 1
alert( +(1 - 2) ); // -1
```

Как видно, плюс ничего не изменил в выражениях. Результат -- такой же, как и без него. 

Тем не менее, он широко применяется, так как его "побочный эффект" -- преобразование значения в число.

Например, когда мы получаем значения из HTML-полей или от пользователя, то они обычно в форме строк.

А что, если их нужно, к примеру, сложить? Бинарный плюс сложит их как строки:

```js
//+ run
var apples = "2";
var oranges = "3";

alert( apples + oranges ); // "23", так как бинарный плюс складывает строки
```

Поэтому используем унарный плюс, чтобы преобразовать к числу:

```js
//+ run
var apples = "2";
var oranges = "3";

alert( +apples + +oranges); // 5, число, оба операнда предварительно преобразованы в числа
```

С точки зрения математики такое изобилие плюсов может показаться странным. С точки зрения программирования -- никаких разночтений: сначала выполнятся унарные плюсы, приведут строки к числам, а затем -- бинарный `'+'` их сложит.

Почему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете.

## Приоритет


В том случае, если в выражении есть несколько операторов -- порядок их выполнения определяется *приоритетом*.

Из школы мы знаем, что умножение в выражении `2 * 2 + 1` выполнится раньше сложения, т.к. его *приоритет* выше, а скобки явно задают порядок выполнения. Но в JavaScript -- гораздо больше операторов, поэтому существует целая [таблица приоритетов](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence). 

Она содержит как уже пройденные операторы, так и те, которые мы еще не проходили. В ней каждому оператору задан числовой приоритет. Тот, у кого число меньше -- выполнится раньше. Если приоритет одинаковый, то порядок выполнения -- слева направо.

Отрывок из таблицы:

<table>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>4</td><td>унарный плюс</td><td>`+`</td></tr>
<tr><td>4</td><td>унарный минус</td><td>`-`</td></tr>
<tr><td>5</td><td>умножение</td><td>`*`</td></tr>
<tr><td>5</td><td>деление</td><td>`/`</td></tr>
<tr><td>6</td><td>сложение</td><td>`+`</td></tr>
<tr><td>6</td><td>вычитание</td><td>`-`</td></tr>
<tr><td>17</td><td>присвоение</td><td>`=`</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
</table>

Так как "унарный плюс" имеет приоритет `4`, выше, чем `6` у обычного "сложения", то в выражении `+apples + +oranges` сначала сработали плюсы у `apples` и `oranges`, а затем уже обычное сложение.

## Присваивание

Обратим внимание, в таблице приоритетов также есть оператор присваивания `=`.

У него -- один из самых низких приоритетов: `17`.

Именно поэтому, когда переменную чему-либо присваивают, например, `x = 2 * 2 + 1` сначала выполнится арифметика, а уже затем -- произойдёт присвоение `=`. 

```js
var x = 2 * 2 + 1;

alert(x); // 5
```

**Возможно присваивание по цепочке:**

```js
//+ run
var a, b, c;

*!*
a = b = c = 2 + 2;
*/!*

alert(a); // 4
alert(b); // 4
alert(c); // 4
```

Такое присваивание работает справа-налево, то есть сначала вычислятся самое правое выражение `2+2`, присвоится в `c`, затем выполнится `b = c` и, наконец, `a = b`.

[smart header="Оператор `\"=\"` возвращает значение"]
Все операторы возвращают значение. Вызов `x = выражение` не является исключением.

Он записывает выражение в `x`, а затем возвращает его. Благодаря этому присваивание можно использовать как часть более сложного выражения:

```js
//+ run
var a = 1;
var b = 2;

*!*
var c = 3 - (a = b + 1);
*/!*

alert(a); // 3
alert(c); // 0
```

В примере выше результатом `(a = b + 1)` является значение, которое записывается в `a` (т.е. `3`). Оно используется для вычисления `c`.

Забавное применение присваивания, не так ли? 

Знать, как это работает -- стоит обязательно, а вот писать самому -- только если вы уверены, что это сделает код более читаемым и понятным.
[/smart]


## Взятие остатка %

Оператор взятия остатка `%` интересен тем, что, несмотря на обозначение, никакого отношения к процентам не имеет. 

Его результат `a % b` -- это остаток от деления `a` на `b`.

Например:

```js
//+ run
alert(5 % 2); // 1, остаток от деления 5 на 2 
alert(8 % 3); // 2, остаток от деления 8 на 3
alert(6 % 3); // 0, остаток от деления 6 на 3
```


## Инкремент/декремент: ++, --   

Одной из наиболее частых операций в JavaScript, как и во многих других языках программирования, является увеличение или уменьшение переменной на единицу.

Для этого существуют даже специальные операторы:
<ul>
<li>**Инкремент** `++` увеличивает на 1:

```js
//+ run
var i = 2;
i++;      // более короткая запись для i = i + 1.
alert(i); // 3
```

</li>
<li>**Декремент** `--` уменьшает на 1:

```js
//+ run
var i = 2;
i--;      // более короткая запись для i = i - 1.
alert(i); // 1
```

</li>
</ul>

[warn]
Инкремент/декремент можно применить только к переменной. 
Код `5++` даст ошибку.
[/warn]

Вызывать эти операторы можно не только после, но и перед переменной: `i++` (называется "постфиксная форма") или `++i` ("префиксная форма"). 

Обе эти формы записи делают одно и то же: увеличивают на `1`. 

Тем не менее, между ними существует разница. Она видна только в том случае, когда мы хотим не только увеличить/уменьшить переменную, но и использовать результат в том же выражении.

Например:

```js
//+ run
var i = 1;
var a = ++i; // (*)

alert(a); // *!*2*/!*
```

В строке `(*)` вызов `++i` увеличит переменную, а *затем* вернёт ее значение в `a`. Так что в `a` попадёт значение `i` *после* увеличения.

**Постфиксная форма `i++` отличается от префиксной `++i` тем, что возвращает старое значение, бывшее до увеличения.** 

В примере ниже в `a` попадёт старое значение `i`, равное `1`:

```js
//+ run
var i = 1;
var a = i++; // (*)

alert(a); // *!*1*/!*
```

<ul>
<li>Если результат оператора не используется, а нужно только увеличить/уменьшить переменную -- без разницы, какую форму использовать:

```js
//+ run
var i = 0;
i++; 
++i; 
alert(i); // 2
```

</li>
<li>Если хочется тут же использовать результат, то нужна префиксная форма:

```js
//+ run
var i = 0;
alert( ++i ); // 1
```

</li>
<li>Если нужно увеличить, но нужно значение переменной *до увеличения* -- постфиксная форма:

```js
//+ run
var i = 0;
alert( i++ ); // 0
```

</li>
</ul>

[smart header="Инкремент/декремент можно использовать в любых выражениях"]

При этом он имеет более высокий приоритет и выполняется раньше, чем арифметические операции:

```js
//+ run
var i = 1;
alert( 2 * ++i ); // 4
```



```js
//+ run
var i = 1;
alert( 2 * i++ ); // 2, выполнился раньше но значение вернул старое
```

При этом, нужно с осторожностью использовать такую запись, потому что в более длинной строке при быстром "вертикальном" чтении кода легко пропустить такой `i++`, и будет неочевидно, что переменая увеличивается. 

Три строки, по одному действию в каждой -- длиннее, зато нагляднее:

```js
//+ run
var i = 1;
alert( 2 * i );
i++;
```
[/smart]

## Побитовые операторы

Побитовые операторы рассматривают аргументы как 32-разрядные целые числа и работают на уровне их внутреннего двоичного представления.

Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования. 

Поддерживаются следующие побитовые операторы:
<ul>
<li>AND(и) ( `&` )</li>
<li>OR(или) ( `|` )</li>
<li>XOR(побитовое исключающее или) ( `^` )</li>
<li>NOT(не) ( `~` )</li>
<li>LEFT SHIFT(левый сдвиг) ( `<<` )</li>
<li>RIGHT SHIFT(правый сдвиг) ( `>>` )</li>
<li>ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( `>>>` )</li>
</ul>

Они используются редко, поэтому вынесены в отдельную главу [](/bitwise-operators).



## Сокращённая арифметика с присваиванием

Часто нужно применить оператор к переменной и сохранить результат в ней же, например:

```js
var n = 2;
n = n + 5;  
n = n * 2;
```

Эту запись можно укоротить при помощи совмещённых операторов, вот так:

```js
//+ run
var n = 2;
n += 5; // теперь n=7 (работает как n = n + 5)
n *= 2; // теперь n=14 (работает как n = n * 2)

alert(n); // 14
```

Так можно сделать для операторов `+,-,*,/` и бинарных `<<,>>,>>>,&,|,^`.

Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:

```js
//+ run
var n = 2;
n *= 3 + 5; 

alert(n); // 16  (n = 2 * 8)
```


## Оператор запятая

Один из самых необычных операторов -- запятая `','`.

Его можно вызвать явным образом, например:

```js
//+ run
*!*
a = (5, 6);
*/!*

alert(a);
```

Запятая позволяет перечислять выражения, разделяя их запятой `','`. Каждое из них -- вычисляется и отбрасывается, за исключением последнего, которое возвращается. 

Запятая -- единственный оператор, приоритет которого ниже присваивания. В выражении `a = (5,6)` для явного задания приоритета использованы скобки, иначе оператор `'='` выполнился бы до запятой `','`, получилось бы `(a=5), 6`.

Зачем же нужен такой странный оператор, который отбрасывает значения всех перечисленных выражений, кроме последнего?

Обычно он используется в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. Например:

```js
// три операции в одной строке
for (*!*a = 1, b = 3, c = a*b*/!*; a < 10; a++) {
 ...
}
```

Такие трюки используются во многих JavaScript-фреймворках для укорачивания кода.