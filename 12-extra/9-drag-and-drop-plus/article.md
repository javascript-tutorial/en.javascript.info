# Применяем ООП: Drag'n'Drop++

Эта статья представляет собой продолжение главы [](/drag-and-drop-objects). 
Она посвящена более гибкой и расширяемой реализации переноса.

Рекомендуется прочитать указанную главу перед тем, как двигаться дальше.

[cut]
В сложных приложениях Drag'n'Drop обладает рядом особенностей:
<ol>
<li>Перетаскиваются *элементы* из *зоны переноса `dragZone`* в *зону-цель `dropTarget`*. При этом сама зона не переносится.

Например -- два списка, нужен перенос элемента из одного в другой. В этом случае один список является зоной переноса, второй -- зоной-целью. 

Возможно, что перенос осуществляется внутри одного и того же списка. При этом  `dragZone == dropTarget`.
</li>
<li>На странице может быть несколько разных зон переноса и зон-целей.</li>
<li>Обработка завершения переноса может быть асинхронной, с уведомлением сервера.</li>
<li>Должно быть легко добавить новый тип зоны переноса или зоны-цели, а также расширить поведение существующей.</li>
<li>Фреймворк для переноса должен быть расширяемым с учётом сложных сценариев.</li>
</ol>

Всё это вполне реализуемо. Но для этого фреймворк, описанный в статье [](/drag-and-drop-objects), нужно отрефакторить, и разделить на сущности.

## Основные сущности

Всего будет 4 сущности:

<dl>
<dt>`DragZone`</dt>
<dd>Зона переноса. С нее начинается перенос. Она принимает нажатие мыши и генерирует аватар нужного типа.</dd>
<dt>`DragAvatar`</dt>
<dd>Переносимый объект. Предоставляет доступ к информации о том, что переносится. Умеет двигать себя по экрану. В зависимости от вида переноса, может что-то делать с собой в конце, например, самоуничтожаться.</dd>
<dt>`DropTarget`</dt>
<dd>Зона-цель, на которую можно положить. В процессе переноса аватара над ней умеет рисовать на себе предполагаемое "место приземления". Обрабатывает окончание переноса.</dd>
<dt>`dragManager`</dt>
<dd>Единый объект, который стоит над всеми ними, ставит обработчики `mousedown/mousemove/mouseup` и управляет процессом. В терминах ООП, это не класс, а [объект-синглтон](http://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_%28%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29), поэтому он с маленькой буквы.</dd>
</dl>

На макете страницы ниже возможен перенос студентов из левого списка -- вправо, в одну из команд или в "корзину":

<img src="dragzonetarget.png">

Здесь левый список является зоной переноса `ListDragZone`, а правые списки -- это несколько зон-целей `ListDropTarget`. Кроме того, корзина также является зоной-целью отдельного типа `RemoveDropTarget`.

## Пример

В этой статье мы реализуем пример, когда узлы дерева можно переносить внутри него. То есть, дерево, которое является одновременно `TreeDragZone` и `TreeDropTarget`.

Структура дерева будет состоять из вложенных списков с заголовком в `SPAN`:

```html
<ul>
  <li><span>Заголовок 1</span>
    <ul>
      <li><span>Заголовок 1.1</span></li>
      <li><span>Заголовок 1.2</span></li>
      ...
    </ul>
  </li>
  ...
</ul>
```

При переносе:
<ul>
<li>Для аватара нужно клонировать заголовок узла, на котором было нажатие.</li>
<li>Узлы, на которые можно положить, при переносе подсвечиваются красным.</li>
<li>Нельзя перенести узел сам в себя или в своего потомка.</li>
<li>Дерево само поддерживает сортировку по алфавиту среди узлов.</li>
<li>Обязательна расширяемость кода, поддержка большого количества узлов и т.п.</li>
</ul>

[iframe height=450 border=1 src="dragTree"]

## dragManager

Обязанность `dragManager` -- обработка событий мыши и координация всех остальных сущностей в процессе переноса.

**Готовьтесь, дальше будет много кода с комментариями.** 

Следующий код должен быть очевиден по смыслу, если вы читали [предыдущую статью](/drag-and-drop-objects). Объект взят оттуда, и из него изъята лишняя функциональность, которая перенесена в другие сущности.

Если вызываемые в нём методы `onDrag*` непонятны -- смотрите далее, в описание остальных объектов.

```js
//+ src="DragManager.js"
```

## DragZone

Основная задача `DragZone` -- создать аватар и инициализовать его. В зависимости от места, где произошел клик, аватар получит соответствующий подэлемент зоны.

Метод для создания аватара `_makeAvatar` вынесен отдельно, чтобы его легко можно было переопределить и подставить собственный тип аватара.

```js
//+ src="DragZone.js"
```

### TreeDragZone

Объект зоны переноса для дерева, по существу, не вносит ничего нового, по сравнению с `DragZone`.

Он только переопределяет `_makeAvatar` для создания `TreeDragAvatar`.

```js
//+ src="TreeDragZone.js"
```

## DragAvatar

Аватар создается только зоной переноса при начале Drag'n'Drop. Он содержит всю необходимую информацию об объекте, который переносится. 

В дальнейшем вся работа происходит *только с аватаром*, сама зона напрямую не вызывается.

У аватара есть три основных свойства:
<dl>
<dt>`_dragZone`</dt>
<dd>Зона переноса, которая его создала.</dd>
<dt>`_dragZoneElem`</dt>
<dd>Элемент, соответствующий аватару в зоне переноса. По умолчанию -- DOM-элемент всей зоны. Это подходит в тех случаях, когда зона перетаскивается только целиком.
При инициализации аватара значение этого свойства быть уточнено, например изменено на подэлемент списка, который перетаскивается.</dd>
<dt>`_elem`</dt>
<dd>Основной элемент аватара, который будет двигаться по экрану. По умолчанию  равен `_dragZoneElem`, т.е мы переносим сам элемент.
 
При инициализации мы можем также склонировать `_dragZoneElem`, или создать своё красивое представление переносимого элемента и поместить его в `_elem`.</dd>
</dl>

```js
//+ src="DragAvatar.js"
```

### TreeDragAvatar

Основные изменения -- в методе `initFromEvent`, который создает аватар из узла, на котором был клик. 

Обратите внимание, возможно что клик был не на заголовке `SPAN`, а просто где-то на дереве. В этом случае `initFromEvent` возвращает `false` и перенос не начинается.

```js
//+ src="TreeDragAvatar.js"
```

## DropTarget

Именно на `DropTarget` ложится работа по отображению предполагаемой "точки приземления" аватара, а также, по завершению переноса, обработка результата. 

Как правило, `DropTarget` принимает переносимый узел в себя, а вот как конкретно организован процесс вставки -- нужно описать в классе-наследнике. Разные типы зон делают разное при вставке: `TreeDropTarget` вставляет элемент в качестве потомка, а `RemoveDropTarget` -- удаляет.

```js
//+ src="DropTarget.js"
```

Как видно, из кода выше, по умолчанию `DropTarget` занимается только отслеживанием и индикацией "точки приземления". По умолчанию, единственной возможной "точкой приземления" является сам элемент зоны. В более сложных ситуациях это может быть подэлемент.

Для применения в реальности необходимо как минимум переопределить обработку результата переноса в `onDragEnd`. 

### TreeDropTarget

`TreeDropTarget` содержит код, специфичный для дерева:
<ul>
<li>Индикацию переноса над элементом: методы `_showHoverIndication` и `_hideHoverIndication`.</li>
<li>Получение текущей точки приземления `_targetElem` в методе `_getTargetElem`. Ей может быть только заголовок узла дерева, причем дополнительно проверяется, что это не потомок переносимого узла.</li>
<li>Обработка успешного переноса в `onDragEnd`, вставка исходного узла `avatar.dragZoneElem` в узел, соответствующий `_targetElem`.</li>
</ul>

```js
//+ src="TreeDropTarget.js"
```

## Итого 


Реализация Drag'n'Drop оказалась отличным способом применить ООП в JavaScript.

Исходный код примера целиком находится [edit src="dragTree"]в песочнице[/edit].

<ul>
<li>Синглтон `dragManager` и классы `Drag*` задают общий фреймворк. От них наследуются конкретные объекты. Для создания новых зон достаточно унаследовать стандартные классы и переопределить их. </li>
<li>Мини-фреймворк для Drag'n'Drop, который здесь представлен, является переписанным и обновленным вариантом реальной библиотеки, на основе которой было создано много успешных скриптов переноса. 

В зависимости от ваших потребностей, вы можете расширить его, добавить перенос нескольких объектов одновременно, поддержку событий и другие возможности.</li>
<li>На сегодняшний день в каждом серьезном фреймворке есть библиотека для Drag'n'Drop. Она работает похожим образом, но сделать универсальный перенос -- штука непростая. Зачастую он перегружен лишним функционалом, либо наоборот -- недостаточно расширяем в нужных местах. 
Понимание, как это все может быть устроено, на примере этой статьи, может помочь в адаптации существующего кода под ваши потребности.</li>
</ul>

[head]
<script>
function getElementUnderClientXY(elem, clientX, clientY) {
  var display = elem.style.display || '';
  elem.style.display = 'none';

  var target = document.elementFromPoint(clientX, clientY);

  elem.style.display = display;

  if (!target || target == document) { 
    target = document.body; 
  }

  return target;
}

</script>
[/head]
[libs]
getCoords.js
[/libs]