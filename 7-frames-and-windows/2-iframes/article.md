# Окно внутри ифрейма

Элемент `iframe` является обычным узлом DOM, как и любой другой. Существенное отличие -- в том, что с ним связан объект `window` внутреннего окна. Он доступен по ссылке `iframe.contentWindow`.

[cut]

Таким образом, `iframe.contentWindow.document` будет внутренним документом, `iframe.contentWindow.document.body` -- его `<body>` и так далее.

[smart header="Когда-то..."]
В старых браузерах использовались другие свойства, такие как `iframe.contentDocument` и даже `iframe.document`, но они давно не нужны.
[/smart]

## Переход внутрь ифрейма

В примере ниже JavaScript получает документ внутри ифрейма и модифицирует его:

```html
<!--+ run height=100 -->
<iframe src="javascript:'тест'" style="height:60px"></iframe>

<script>
  var iframe = document.getElementsByTagName('iframe')[0];
*!*
  var iframeDoc = iframe.contentWindow.document;
*/!*
  iframeDoc.body.style.backgroundColor = 'green';
</script>
```

[smart header="src='javascript:...'"]
Атрибут `src` может использовать протокол `javascript:...`. При этом код выполняется и его результат будет содержимым ифрейма. Этот способ описан в стандарте и поддерживается всеми браузерами.

Атрибут `src` является обязательным, и его отсутствие может привести к проблемам, вплоть до игнорирования ифрейма браузером. Чтобы ничего не загружать в ифрейм, можно указать пустую строку: `src="javascript:''"`.
[/smart]

## Кросс-доменность: ограничение доступа к окну

Элемент `<iframe>` является "двуличным". С одной стороны, это обычный узел DOM, с другой -- внутри находится окно, которое может иметь совершенно другой URL, содержать независимый документ из другого источника.

Внешний документ имеет полный доступ к `<iframe>` как к DOM-узлу. А вот к окну -- если они с одного источника.

Это приводит к забавным последствиям. Например, чтобы узнать об окончании загрузки `<iframe>`, мы можем повесить обработчик `iframe.onload`. По сути, это то же самое что `iframe.contentWindow.onload`, но его мы можем поставить лишь в случае, если окно с того же источника.

```html
<!--+ run height=120 -->
<iframe src="http://example.com" style="height:100px"></iframe>

<script>
  var iframe = document.getElementsByTagName('iframe')[0];

  // сработает
  iframe.onload = function() { 
    alert("iframe onload"); 
  };

  // не сработает
  iframe.contentWindow.onload = function() { 
    alert("contentWindow onload"); 
  };
</script>
```

Если бы в примере выше `<iframe src>` был с текущего сайта, то оба обработчика сработали бы.

## Иерархия window.frames   

Альтернативный способ доступа к окну ифрейма -- это получить его из коллекции `window.frames`.

Есть два способа доступа:
<ol>
<li>`window.frames[0]` -- доступ по номеру.</li>
<li>`window.frames.iframeName` -- доступ по `name` ифрейма.</li>
</ol>

Обратим внимание: в коллекции хранится именно окно (`contentWindow`), а не DOM-элемент.

Демонстрация всех способов доступа к окну:

```html
<!--+ run -->
<iframe src="javascript:''" style="height:80px" name="i"></iframe>

<script>  
  var iframeTag = document.body.children[0];

  var iframeWindow = iframe.contentWindow; // окно из тега

  alert(frames[0] === iframeWindow); // true, окно из коллекции frames
  alert(frames.i == iframeWindow); // true, окно из frames по имени
</script>
```

Внутри ифрейма могут быть свои вложенные ифреймы. Всё это вместе образует иерархию.

Ссылки для навигации по ней:

<ul>
<li>`window.frames` -- коллекция "детей" (вложенных ифреймов)</li>
<li>`window.parent` -- содержит ссылку на родительское окно, позволяет обратиться к нему из ифрейма.

Всегда верно:

```js
// (из окна со фреймом)
window.frames[0].parent === window; // true
```

</li>
<li>`window.top` -- содержит ссылку на самое верхнее окно (вершину иерархии).

Всегда верно (в предположении, что вложенные фреймы существуют):

```js
window.frames[0].frames[0].frames[0].top === window
```

</li>
</ul>

**Свойство `top` позволяет легко проверить, во фрейме ли находится текущий документ:**

```js
//+ run
if (window == top) {
  alert('Этот скрипт является окном верхнего уровня в браузере');
} else {
  alert('Этот скрипт исполняется во фрейме!');
}
```

## Песочница sandbox

Атрибут `sandbox` позволяет построить "песочницу" вокруг ифрейма, запретив ему выполнять ряд действий.

Наличие атрибута `sandbox`:
<ul>
<li>Заставляет браузер считать ифрейм загруженным с другого источника, так что он и внешнее окно больше не могут обращаться к переменным друг друга.</li>
<li>Отключает формы и скрипты в ифрейме.</li>
<li>Запрещает менять `parent.location` из ифрейма.</li>
</ul>

Пример ниже загружает в `<iframe sandbox>` документ с JavaScript и формой. Ни то ни другое не сработает:

[codetabs src="sandbox"]

Если у атрибута `sandbox` нет значения, то браузер применяет максимум ограничений.

Атрибут `sandbox` может содержать через пробел список ограничений, которые не нужны:
<dl>
<dt>allow-same-origin</dt>
<dd>Браузер может не считать документ в ифрейме пришедшим с другого же домена. Если ифрейм *и так* с другого домена, то ничего не меняется.</dd>
<dt>allow-top-navigation</dt>
<dd>Разрешает ифрейму менять `parent.location`.</dd>
<dt>allow-forms</dt>
<dd>Разрешает отправлять формы из `iframe`.</dd>
<dt>allow-scripts</dt>
<dd>Разрешает выполнение скриптов из ифрейма. Но скриптам, всё же, будет запрещено открывать попапы.</dd>
</dl>

[smart]
Цель атрибута `sandbox` -- наложить дополнительные ограничения. Он не может снять уже существующие, в частности, убрать ограничения безопасности, если ифрейм с другого источника. 
[/smart]